/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {IHttpClient} from "aurelia";

export interface IScriptsService {
    getScripts(): Promise<ScriptSummary[]>;
    create(): Promise<void>;
    save(id: string): Promise<void>;
    run(id: string): Promise<void>;
    updateCode(id: string, code: string): Promise<void>;
    openConfig(id: string): Promise<void>;
    setConfig(id: string, config: ScriptConfig): Promise<FileResponse | null>;
}

export class ScriptsService implements IScriptsService {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getScripts(signal?: AbortSignal | undefined): Promise<ScriptSummary[]> {
        let url_ = this.baseUrl + "/scripts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScripts(_response);
        });
    }

    protected processGetScripts(response: Response): Promise<ScriptSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScriptSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptSummary[]>(<any>null);
    }

    create(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/create";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    save(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/save";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    run(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/run";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    updateCode(id: string, code: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/code";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCode(_response);
        });
    }

    protected processUpdateCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    openConfig(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/open-config";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenConfig(_response);
        });
    }

    protected processOpenConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    setConfig(id: string, config: ScriptConfig, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/scripts/{id}/config";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetConfig(_response);
        });
    }

    protected processSetConfig(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export interface ISessionService {
    getEnvironment(scriptId: string): Promise<ScriptEnvironment>;
    getEnvironments(): Promise<ScriptEnvironment[]>;
    open(scriptPath: string | null | undefined): Promise<void>;
    close(scriptId: string): Promise<void>;
    getActive(): Promise<string | null>;
    setActive(scriptId: string): Promise<void>;
}

export class SessionService implements ISessionService {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEnvironment(scriptId: string, signal?: AbortSignal | undefined): Promise<ScriptEnvironment> {
        let url_ = this.baseUrl + "/session/environments/{scriptId}";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnvironment(_response);
        });
    }

    protected processGetEnvironment(response: Response): Promise<ScriptEnvironment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScriptEnvironment.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptEnvironment>(<any>null);
    }

    getEnvironments(signal?: AbortSignal | undefined): Promise<ScriptEnvironment[]> {
        let url_ = this.baseUrl + "/session/environments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnvironments(_response);
        });
    }

    protected processGetEnvironments(response: Response): Promise<ScriptEnvironment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScriptEnvironment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptEnvironment[]>(<any>null);
    }

    open(scriptPath: string | null | undefined, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/open?";
        if (scriptPath !== undefined && scriptPath !== null)
            url_ += "scriptPath=" + encodeURIComponent("" + scriptPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpen(_response);
        });
    }

    protected processOpen(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    close(scriptId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/close/{scriptId}";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    getActive(signal?: AbortSignal | undefined): Promise<string | null> {
        let url_ = this.baseUrl + "/session/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActive(_response);
        });
    }

    protected processGetActive(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    setActive(scriptId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/set-active/{scriptId}";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActive(_response);
        });
    }

    protected processSetActive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ISettingsService {
    get(): Promise<Settings>;
}

export class SettingsService implements ISettingsService {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(signal?: AbortSignal | undefined): Promise<Settings> {
        let url_ = this.baseUrl + "/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Settings.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(<any>null);
    }
}

export interface ITypesService {
    getAllTypes(): Promise<ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged | null>;
}

export class TypesService implements ITypesService {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllTypes(signal?: AbortSignal | undefined): Promise<ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged | null> {
        let url_ = this.baseUrl + "/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTypes(_response);
        });
    }

    protected processGetAllTypes(response: Response): Promise<ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged | null>(<any>null);
    }
}

export class ScriptSummary implements IScriptSummary {
    name!: string;
    path!: string;

    constructor(data?: IScriptSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): ScriptSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        return data; 
    }

    clone(): ScriptSummary {
        const json = this.toJSON();
        let result = new ScriptSummary();
        result.init(json);
        return result;
    }
}

export interface IScriptSummary {
    name: string;
    path: string;
}

export class ScriptConfig implements IScriptConfig {
    kind!: ScriptKind;
    namespaces!: string[];

    constructor(data?: IScriptConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.namespaces = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
            if (Array.isArray(_data["namespaces"])) {
                this.namespaces = [] as any;
                for (let item of _data["namespaces"])
                    this.namespaces!.push(item);
            }
        }
    }

    static fromJS(data: any): ScriptConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        if (Array.isArray(this.namespaces)) {
            data["namespaces"] = [];
            for (let item of this.namespaces)
                data["namespaces"].push(item);
        }
        return data; 
    }

    clone(): ScriptConfig {
        const json = this.toJSON();
        let result = new ScriptConfig();
        result.init(json);
        return result;
    }
}

export interface IScriptConfig {
    kind: ScriptKind;
    namespaces: string[];
}

export type ScriptKind = "Expression" | "Statements" | "Program";

export class ScriptEnvironment implements IScriptEnvironment {
    script!: Script;
    status!: ScriptStatus;
    runDurationMilliseconds!: number;

    constructor(data?: IScriptEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.script = new Script();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.script = _data["script"] ? Script.fromJS(_data["script"]) : new Script();
            this.status = _data["status"];
            this.runDurationMilliseconds = _data["runDurationMilliseconds"];
        }
    }

    static fromJS(data: any): ScriptEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["script"] = this.script ? this.script.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["runDurationMilliseconds"] = this.runDurationMilliseconds;
        return data; 
    }

    clone(): ScriptEnvironment {
        const json = this.toJSON();
        let result = new ScriptEnvironment();
        result.init(json);
        return result;
    }
}

export interface IScriptEnvironment {
    script: Script;
    status: ScriptStatus;
    runDurationMilliseconds: number;
}

export class Script implements IScript {
    id!: string;
    name!: string;
    path?: string | undefined;
    config!: ScriptConfig;
    code!: string;
    directoryPath?: string | undefined;
    isDirty!: boolean;
    isNew!: boolean;

    constructor(data?: IScript) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.config = new ScriptConfig();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.config = _data["config"] ? ScriptConfig.fromJS(_data["config"]) : new ScriptConfig();
            this.code = _data["code"];
            this.directoryPath = _data["directoryPath"];
            this.isDirty = _data["isDirty"];
            this.isNew = _data["isNew"];
        }
    }

    static fromJS(data: any): Script {
        data = typeof data === 'object' ? data : {};
        let result = new Script();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["directoryPath"] = this.directoryPath;
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        return data; 
    }

    clone(): Script {
        const json = this.toJSON();
        let result = new Script();
        result.init(json);
        return result;
    }
}

export interface IScript {
    id: string;
    name: string;
    path?: string | undefined;
    config: ScriptConfig;
    code: string;
    directoryPath?: string | undefined;
    isDirty: boolean;
    isNew: boolean;
}

export type ScriptStatus = "Ready" | "Running" | "Stopping" | "Error";

export class Settings implements ISettings {
    scriptsDirectoryPath!: string;

    constructor(data?: ISettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptsDirectoryPath = _data["scriptsDirectoryPath"];
        }
    }

    static fromJS(data: any): Settings {
        data = typeof data === 'object' ? data : {};
        let result = new Settings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptsDirectoryPath"] = this.scriptsDirectoryPath;
        return data; 
    }

    clone(): Settings {
        const json = this.toJSON();
        let result = new Settings();
        result.init(json);
        return result;
    }
}

export interface ISettings {
    scriptsDirectoryPath: string;
}

export class ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged implements IValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged {
    item1!: Script;
    item2!: ScriptPropertyChanged;
    item3!: ScriptOutputEmitted;
    item4!: EnvironmentsAdded;
    item5!: EnvironmentsRemoved;
    item6!: EnvironmentPropertyChanged;
    item7!: ActiveEnvironmentChanged;

    constructor(data?: IValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.item1 = new Script();
            this.item2 = new ScriptPropertyChanged();
            this.item3 = new ScriptOutputEmitted();
            this.item4 = new EnvironmentsAdded();
            this.item5 = new EnvironmentsRemoved();
            this.item6 = new EnvironmentPropertyChanged();
            this.item7 = new ActiveEnvironmentChanged();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"] ? Script.fromJS(_data["item1"]) : new Script();
            this.item2 = _data["item2"] ? ScriptPropertyChanged.fromJS(_data["item2"]) : new ScriptPropertyChanged();
            this.item3 = _data["item3"] ? ScriptOutputEmitted.fromJS(_data["item3"]) : new ScriptOutputEmitted();
            this.item4 = _data["item4"] ? EnvironmentsAdded.fromJS(_data["item4"]) : new EnvironmentsAdded();
            this.item5 = _data["item5"] ? EnvironmentsRemoved.fromJS(_data["item5"]) : new EnvironmentsRemoved();
            this.item6 = _data["item6"] ? EnvironmentPropertyChanged.fromJS(_data["item6"]) : new EnvironmentPropertyChanged();
            this.item7 = _data["item7"] ? ActiveEnvironmentChanged.fromJS(_data["item7"]) : new ActiveEnvironmentChanged();
        }
    }

    static fromJS(data: any): ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1 ? this.item1.toJSON() : <any>undefined;
        data["item2"] = this.item2 ? this.item2.toJSON() : <any>undefined;
        data["item3"] = this.item3 ? this.item3.toJSON() : <any>undefined;
        data["item4"] = this.item4 ? this.item4.toJSON() : <any>undefined;
        data["item5"] = this.item5 ? this.item5.toJSON() : <any>undefined;
        data["item6"] = this.item6 ? this.item6.toJSON() : <any>undefined;
        data["item7"] = this.item7 ? this.item7.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged {
        const json = this.toJSON();
        let result = new ValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged();
        result.init(json);
        return result;
    }
}

export interface IValueTupleOfScriptAndScriptPropertyChangedAndScriptOutputEmittedAndEnvironmentsAddedAndEnvironmentsRemovedAndEnvironmentPropertyChangedAndActiveEnvironmentChanged {
    item1: Script;
    item2: ScriptPropertyChanged;
    item3: ScriptOutputEmitted;
    item4: EnvironmentsAdded;
    item5: EnvironmentsRemoved;
    item6: EnvironmentPropertyChanged;
    item7: ActiveEnvironmentChanged;
}

export class ScriptPropertyChanged implements IScriptPropertyChanged {
    scriptId!: string;
    propertyName!: string;
    newValue?: any | undefined;

    constructor(data?: IScriptPropertyChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
            this.propertyName = _data["propertyName"];
            this.newValue = _data["newValue"];
        }
    }

    static fromJS(data: any): ScriptPropertyChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptPropertyChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        data["propertyName"] = this.propertyName;
        data["newValue"] = this.newValue;
        return data; 
    }

    clone(): ScriptPropertyChanged {
        const json = this.toJSON();
        let result = new ScriptPropertyChanged();
        result.init(json);
        return result;
    }
}

export interface IScriptPropertyChanged {
    scriptId: string;
    propertyName: string;
    newValue?: any | undefined;
}

export class ScriptOutputEmitted implements IScriptOutputEmitted {
    scriptId!: string;
    output?: string | undefined;

    constructor(data?: IScriptOutputEmitted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): ScriptOutputEmitted {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptOutputEmitted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        data["output"] = this.output;
        return data; 
    }

    clone(): ScriptOutputEmitted {
        const json = this.toJSON();
        let result = new ScriptOutputEmitted();
        result.init(json);
        return result;
    }
}

export interface IScriptOutputEmitted {
    scriptId: string;
    output?: string | undefined;
}

export class EnvironmentsAdded implements IEnvironmentsAdded {
    environments!: ScriptEnvironment[];

    constructor(data?: IEnvironmentsAdded) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.environments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["environments"])) {
                this.environments = [] as any;
                for (let item of _data["environments"])
                    this.environments!.push(ScriptEnvironment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvironmentsAdded {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentsAdded();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.environments)) {
            data["environments"] = [];
            for (let item of this.environments)
                data["environments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EnvironmentsAdded {
        const json = this.toJSON();
        let result = new EnvironmentsAdded();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentsAdded {
    environments: ScriptEnvironment[];
}

export class EnvironmentsRemoved implements IEnvironmentsRemoved {
    environments!: ScriptEnvironment[];

    constructor(data?: IEnvironmentsRemoved) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.environments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["environments"])) {
                this.environments = [] as any;
                for (let item of _data["environments"])
                    this.environments!.push(ScriptEnvironment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvironmentsRemoved {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentsRemoved();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.environments)) {
            data["environments"] = [];
            for (let item of this.environments)
                data["environments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EnvironmentsRemoved {
        const json = this.toJSON();
        let result = new EnvironmentsRemoved();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentsRemoved {
    environments: ScriptEnvironment[];
}

export class EnvironmentPropertyChanged implements IEnvironmentPropertyChanged {
    scriptId!: string;
    propertyName!: string;
    newValue?: any | undefined;

    constructor(data?: IEnvironmentPropertyChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
            this.propertyName = _data["propertyName"];
            this.newValue = _data["newValue"];
        }
    }

    static fromJS(data: any): EnvironmentPropertyChanged {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentPropertyChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        data["propertyName"] = this.propertyName;
        data["newValue"] = this.newValue;
        return data; 
    }

    clone(): EnvironmentPropertyChanged {
        const json = this.toJSON();
        let result = new EnvironmentPropertyChanged();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentPropertyChanged {
    scriptId: string;
    propertyName: string;
    newValue?: any | undefined;
}

export class ActiveEnvironmentChanged implements IActiveEnvironmentChanged {
    scriptId?: string | undefined;

    constructor(data?: IActiveEnvironmentChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
        }
    }

    static fromJS(data: any): ActiveEnvironmentChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveEnvironmentChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        return data; 
    }

    clone(): ActiveEnvironmentChanged {
        const json = this.toJSON();
        let result = new ActiveEnvironmentChanged();
        result.init(json);
        return result;
    }
}

export interface IActiveEnvironmentChanged {
    scriptId?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}