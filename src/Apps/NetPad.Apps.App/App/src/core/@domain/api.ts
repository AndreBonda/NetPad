/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {IHttpClient} from "aurelia";

export interface IAppApiClient {

    openScriptsFolder(path: string | null | undefined): Promise<FileResponse | null>;

    openPackageCacheFolder(): Promise<FileResponse | null>;
}

export class AppApiClient implements IAppApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    openScriptsFolder(path: string | null | undefined, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/app/open-scripts-folder?";
        if (path !== undefined && path !== null)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenScriptsFolder(_response);
        });
    }

    protected processOpenScriptsFolder(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    openPackageCacheFolder(signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/app/open-package-cache-folder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenPackageCacheFolder(_response);
        });
    }

    protected processOpenPackageCacheFolder(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export interface IAssembliesApiClient {

    getNamespaces(reference: Reference): Promise<string[]>;
}

export class AssembliesApiClient implements IAssembliesApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getNamespaces(reference: Reference, signal?: AbortSignal | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/assemblies/namespaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reference);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNamespaces(_response);
        });
    }

    protected processGetNamespaces(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export interface IPackagesApiClient {

    getCachedPackages(loadMetadata: boolean | undefined): Promise<CachedPackage[]>;

    deleteCachedPackage(packageId: string | null | undefined, packageVersion: string | null | undefined): Promise<FileResponse | null>;

    search(term: string | null | undefined, skip: number | null | undefined, take: number | null | undefined, includePrerelease: boolean | null | undefined): Promise<PackageMetadata[]>;

    download(packageId: string | null | undefined, packageVersion: string | null | undefined): Promise<FileResponse | null>;
}

export class PackagesApiClient implements IPackagesApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCachedPackages(loadMetadata: boolean | undefined, signal?: AbortSignal | undefined): Promise<CachedPackage[]> {
        let url_ = this.baseUrl + "/packages/cached?";
        if (loadMetadata === null)
            throw new Error("The parameter 'loadMetadata' cannot be null.");
        else if (loadMetadata !== undefined)
            url_ += "loadMetadata=" + encodeURIComponent("" + loadMetadata) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCachedPackages(_response);
        });
    }

    protected processGetCachedPackages(response: Response): Promise<CachedPackage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CachedPackage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CachedPackage[]>(<any>null);
    }

    deleteCachedPackage(packageId: string | null | undefined, packageVersion: string | null | undefined, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/packages/cached?";
        if (packageId !== undefined && packageId !== null)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        if (packageVersion !== undefined && packageVersion !== null)
            url_ += "packageVersion=" + encodeURIComponent("" + packageVersion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCachedPackage(_response);
        });
    }

    protected processDeleteCachedPackage(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    search(term: string | null | undefined, skip: number | null | undefined, take: number | null | undefined, includePrerelease: boolean | null | undefined, signal?: AbortSignal | undefined): Promise<PackageMetadata[]> {
        let url_ = this.baseUrl + "/packages/search?";
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take !== undefined && take !== null)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (includePrerelease !== undefined && includePrerelease !== null)
            url_ += "includePrerelease=" + encodeURIComponent("" + includePrerelease) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PackageMetadata[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PackageMetadata.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PackageMetadata[]>(<any>null);
    }

    download(packageId: string | null | undefined, packageVersion: string | null | undefined, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/packages/download?";
        if (packageId !== undefined && packageId !== null)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        if (packageVersion !== undefined && packageVersion !== null)
            url_ += "packageVersion=" + encodeURIComponent("" + packageVersion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export interface IScriptsApiClient {

    getScripts(): Promise<ScriptSummary[]>;

    create(): Promise<void>;

    save(id: string): Promise<void>;

    run(id: string): Promise<void>;

    updateCode(id: string, code: string): Promise<void>;

    openConfigWindow(id: string): Promise<void>;

    setScriptNamespaces(id: string, namespaces: string[]): Promise<FileResponse | null>;

    setReferences(id: string, references: Reference[]): Promise<FileResponse | null>;

    setScriptKind(id: string, scriptKind: ScriptKind): Promise<FileResponse | null>;
}

export class ScriptsApiClient implements IScriptsApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getScripts(signal?: AbortSignal | undefined): Promise<ScriptSummary[]> {
        let url_ = this.baseUrl + "/scripts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScripts(_response);
        });
    }

    protected processGetScripts(response: Response): Promise<ScriptSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScriptSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptSummary[]>(<any>null);
    }

    create(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/create";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    save(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/save";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    run(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/run";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    updateCode(id: string, code: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/code";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCode(_response);
        });
    }

    protected processUpdateCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    openConfigWindow(id: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/scripts/{id}/open-config";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenConfigWindow(_response);
        });
    }

    protected processOpenConfigWindow(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    setScriptNamespaces(id: string, namespaces: string[], signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/scripts/{id}/namespaces";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(namespaces);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetScriptNamespaces(_response);
        });
    }

    protected processSetScriptNamespaces(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    setReferences(id: string, references: Reference[], signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/scripts/{id}/references";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(references);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetReferences(_response);
        });
    }

    protected processSetReferences(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    setScriptKind(id: string, scriptKind: ScriptKind, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/scripts/{id}/kind";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scriptKind);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetScriptKind(_response);
        });
    }

    protected processSetScriptKind(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export interface ISessionApiClient {

    getEnvironment(scriptId: string): Promise<ScriptEnvironment>;

    getEnvironments(): Promise<ScriptEnvironment[]>;

    open(scriptPath: string | null | undefined): Promise<void>;

    close(scriptId: string): Promise<void>;

    getActive(): Promise<string | null>;

    activate(scriptId: string): Promise<void>;

    activateLastActive(): Promise<void>;
}

export class SessionApiClient implements ISessionApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEnvironment(scriptId: string, signal?: AbortSignal | undefined): Promise<ScriptEnvironment> {
        let url_ = this.baseUrl + "/session/environments/{scriptId}";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnvironment(_response);
        });
    }

    protected processGetEnvironment(response: Response): Promise<ScriptEnvironment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScriptEnvironment.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptEnvironment>(<any>null);
    }

    getEnvironments(signal?: AbortSignal | undefined): Promise<ScriptEnvironment[]> {
        let url_ = this.baseUrl + "/session/environments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnvironments(_response);
        });
    }

    protected processGetEnvironments(response: Response): Promise<ScriptEnvironment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScriptEnvironment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScriptEnvironment[]>(<any>null);
    }

    open(scriptPath: string | null | undefined, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/open?";
        if (scriptPath !== undefined && scriptPath !== null)
            url_ += "scriptPath=" + encodeURIComponent("" + scriptPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpen(_response);
        });
    }

    protected processOpen(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    close(scriptId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/{scriptId}/close";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    getActive(signal?: AbortSignal | undefined): Promise<string | null> {
        let url_ = this.baseUrl + "/session/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActive(_response);
        });
    }

    protected processGetActive(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    activate(scriptId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/{scriptId}/activate";
        if (scriptId === undefined || scriptId === null)
            throw new Error("The parameter 'scriptId' must be defined.");
        url_ = url_.replace("{scriptId}", encodeURIComponent("" + scriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    activateLastActive(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/session/activate-last-active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivateLastActive(_response);
        });
    }

    protected processActivateLastActive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ISettingsApiClient {

    get(): Promise<Settings>;

    update(settings: Settings): Promise<FileResponse | null>;

    openSettingsWindow(): Promise<void>;

    showSettingsFile(): Promise<FileResponse | null>;
}

export class SettingsApiClient implements ISettingsApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(signal?: AbortSignal | undefined): Promise<Settings> {
        let url_ = this.baseUrl + "/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Settings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Settings.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Settings>(<any>null);
    }

    update(settings: Settings, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    openSettingsWindow(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + "/settings/open";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenSettingsWindow(_response);
        });
    }

    protected processOpenSettingsWindow(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    showSettingsFile(signal?: AbortSignal | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/settings/show-settings-file";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShowSettingsFile(_response);
        });
    }

    protected processShowSettingsFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export interface ITypesApiClient {

    additionalTypes(): Promise<Types>;
}

export class TypesApiClient implements ITypesApiClient {
    private http: IHttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, @IHttpClient http?: IHttpClient) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    additionalTypes(signal?: AbortSignal | undefined): Promise<Types> {
        let url_ = this.baseUrl + "/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdditionalTypes(_response);
        });
    }

    protected processAdditionalTypes(response: Response): Promise<Types> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Types.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Types>(<any>null);
    }
}

export abstract class Reference implements IReference {
    title!: string;

    protected _discriminator: string;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Reference";
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): Reference {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "AssemblyReference") {
            let result = new AssemblyReference();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PackageReference") {
            let result = new PackageReference();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Reference' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["title"] = this.title;
        return data;
    }

    clone(): Reference {
        throw new Error("The abstract class 'Reference' cannot be instantiated.");
    }
}

export interface IReference {
    title: string;
}

export class AssemblyReference extends Reference implements IAssemblyReference {
    assemblyPath?: string | undefined;

    constructor(data?: IAssemblyReference) {
        super(data);
        this._discriminator = "AssemblyReference";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.assemblyPath = _data["assemblyPath"];
        }
    }

    static fromJS(data: any): AssemblyReference {
        data = typeof data === 'object' ? data : {};
        let result = new AssemblyReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assemblyPath"] = this.assemblyPath;
        super.toJSON(data);
        return data;
    }

    clone(): AssemblyReference {
        const json = this.toJSON();
        let result = new AssemblyReference();
        result.init(json);
        return result;
    }
}

export interface IAssemblyReference extends IReference {
    assemblyPath?: string | undefined;
}

export class PackageReference extends Reference implements IPackageReference {
    packageId!: string;
    version!: string;

    constructor(data?: IPackageReference) {
        super(data);
        this._discriminator = "PackageReference";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.packageId = _data["packageId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): PackageReference {
        data = typeof data === 'object' ? data : {};
        let result = new PackageReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }

    clone(): PackageReference {
        const json = this.toJSON();
        let result = new PackageReference();
        result.init(json);
        return result;
    }
}

export interface IPackageReference extends IReference {
    packageId: string;
    version: string;
}

export class PackageMetadata implements IPackageMetadata {
    packageId!: string;
    title!: string;
    authors!: string;
    description!: string;
    iconUrl!: string;
    projectUrl!: string;
    packageDetailsUrl!: string;
    licenseUrl!: string;
    readmeUrl!: string;
    reportAbuseUrl!: string;
    dependencies!: string[];
    downloadCount?: number | undefined;
    publishedDate?: Date | undefined;
    version?: string | undefined;

    constructor(data?: IPackageMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dependencies = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.title = _data["title"];
            this.authors = _data["authors"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.projectUrl = _data["projectUrl"];
            this.packageDetailsUrl = _data["packageDetailsUrl"];
            this.licenseUrl = _data["licenseUrl"];
            this.readmeUrl = _data["readmeUrl"];
            this.reportAbuseUrl = _data["reportAbuseUrl"];
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(item);
            }
            this.downloadCount = _data["downloadCount"];
            this.publishedDate = _data["publishedDate"] ? new Date(_data["publishedDate"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): PackageMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new PackageMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["title"] = this.title;
        data["authors"] = this.authors;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["projectUrl"] = this.projectUrl;
        data["packageDetailsUrl"] = this.packageDetailsUrl;
        data["licenseUrl"] = this.licenseUrl;
        data["readmeUrl"] = this.readmeUrl;
        data["reportAbuseUrl"] = this.reportAbuseUrl;
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item);
        }
        data["downloadCount"] = this.downloadCount;
        data["publishedDate"] = this.publishedDate ? this.publishedDate.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }

    clone(): PackageMetadata {
        const json = this.toJSON();
        let result = new PackageMetadata();
        result.init(json);
        return result;
    }
}

export interface IPackageMetadata {
    packageId: string;
    title: string;
    authors: string;
    description: string;
    iconUrl: string;
    projectUrl: string;
    packageDetailsUrl: string;
    licenseUrl: string;
    readmeUrl: string;
    reportAbuseUrl: string;
    dependencies: string[];
    downloadCount?: number | undefined;
    publishedDate?: Date | undefined;
    version?: string | undefined;
}

export class CachedPackage extends PackageMetadata implements ICachedPackage {
    directoryPath!: string;

    constructor(data?: ICachedPackage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.directoryPath = _data["directoryPath"];
        }
    }

    static fromJS(data: any): CachedPackage {
        data = typeof data === 'object' ? data : {};
        let result = new CachedPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["directoryPath"] = this.directoryPath;
        super.toJSON(data);
        return data;
    }

    clone(): CachedPackage {
        const json = this.toJSON();
        let result = new CachedPackage();
        result.init(json);
        return result;
    }
}

export interface ICachedPackage extends IPackageMetadata {
    directoryPath: string;
}

export class ScriptSummary implements IScriptSummary {
    name!: string;
    path!: string;

    constructor(data?: IScriptSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): ScriptSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        return data;
    }

    clone(): ScriptSummary {
        const json = this.toJSON();
        let result = new ScriptSummary();
        result.init(json);
        return result;
    }
}

export interface IScriptSummary {
    name: string;
    path: string;
}

export type ScriptKind = "Expression" | "Statements" | "Program";

export class ScriptEnvironment implements IScriptEnvironment {
    script!: Script;
    status!: ScriptStatus;
    runDurationMilliseconds!: number;

    constructor(data?: IScriptEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.script = new Script();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.script = _data["script"] ? Script.fromJS(_data["script"]) : new Script();
            this.status = _data["status"];
            this.runDurationMilliseconds = _data["runDurationMilliseconds"];
        }
    }

    static fromJS(data: any): ScriptEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["script"] = this.script ? this.script.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["runDurationMilliseconds"] = this.runDurationMilliseconds;
        return data;
    }

    clone(): ScriptEnvironment {
        const json = this.toJSON();
        let result = new ScriptEnvironment();
        result.init(json);
        return result;
    }
}

export interface IScriptEnvironment {
    script: Script;
    status: ScriptStatus;
    runDurationMilliseconds: number;
}

export class Script implements IScript {
    id!: string;
    name!: string;
    path?: string | undefined;
    config!: ScriptConfig;
    code!: string;
    isDirty!: boolean;
    directoryPath?: string | undefined;
    isNew!: boolean;

    constructor(data?: IScript) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.config = new ScriptConfig();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.config = _data["config"] ? ScriptConfig.fromJS(_data["config"]) : new ScriptConfig();
            this.code = _data["code"];
            this.isDirty = _data["isDirty"];
            this.directoryPath = _data["directoryPath"];
            this.isNew = _data["isNew"];
        }
    }

    static fromJS(data: any): Script {
        data = typeof data === 'object' ? data : {};
        let result = new Script();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["isDirty"] = this.isDirty;
        data["directoryPath"] = this.directoryPath;
        data["isNew"] = this.isNew;
        return data;
    }

    clone(): Script {
        const json = this.toJSON();
        let result = new Script();
        result.init(json);
        return result;
    }
}

export interface IScript {
    id: string;
    name: string;
    path?: string | undefined;
    config: ScriptConfig;
    code: string;
    isDirty: boolean;
    directoryPath?: string | undefined;
    isNew: boolean;
}

export class ScriptConfig implements IScriptConfig {
    kind!: ScriptKind;
    namespaces!: string[];
    references!: Reference[];

    constructor(data?: IScriptConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.namespaces = [];
            this.references = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
            if (Array.isArray(_data["namespaces"])) {
                this.namespaces = [] as any;
                for (let item of _data["namespaces"])
                    this.namespaces!.push(item);
            }
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(Reference.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScriptConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        if (Array.isArray(this.namespaces)) {
            data["namespaces"] = [];
            for (let item of this.namespaces)
                data["namespaces"].push(item);
        }
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        return data;
    }

    clone(): ScriptConfig {
        const json = this.toJSON();
        let result = new ScriptConfig();
        result.init(json);
        return result;
    }
}

export interface IScriptConfig {
    kind: ScriptKind;
    namespaces: string[];
    references: Reference[];
}

export type ScriptStatus = "Ready" | "Running" | "Stopping" | "Error";

export class Settings implements ISettings {
    theme!: Theme;
    scriptsDirectoryPath!: string;
    packageCacheDirectoryPath!: string;
    editorBackgroundColor?: string | undefined;
    editorOptions!: any;
    resultsOptions!: ResultsOptions;

    constructor(data?: ISettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.resultsOptions = new ResultsOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.scriptsDirectoryPath = _data["scriptsDirectoryPath"];
            this.packageCacheDirectoryPath = _data["packageCacheDirectoryPath"];
            this.editorBackgroundColor = _data["editorBackgroundColor"];
            this.editorOptions = _data["editorOptions"];
            this.resultsOptions = _data["resultsOptions"] ? ResultsOptions.fromJS(_data["resultsOptions"]) : new ResultsOptions();
        }
    }

    static fromJS(data: any): Settings {
        data = typeof data === 'object' ? data : {};
        let result = new Settings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["scriptsDirectoryPath"] = this.scriptsDirectoryPath;
        data["packageCacheDirectoryPath"] = this.packageCacheDirectoryPath;
        data["editorBackgroundColor"] = this.editorBackgroundColor;
        data["editorOptions"] = this.editorOptions;
        data["resultsOptions"] = this.resultsOptions ? this.resultsOptions.toJSON() : <any>undefined;
        return data;
    }

    clone(): Settings {
        const json = this.toJSON();
        let result = new Settings();
        result.init(json);
        return result;
    }
}

export interface ISettings {
    theme: Theme;
    scriptsDirectoryPath: string;
    packageCacheDirectoryPath: string;
    editorBackgroundColor?: string | undefined;
    editorOptions: any;
    resultsOptions: ResultsOptions;
}

export type Theme = "Light" | "Dark";

export class ResultsOptions implements IResultsOptions {
    openOnRun!: boolean;
    textWrap!: boolean;

    constructor(data?: IResultsOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.openOnRun = _data["openOnRun"];
            this.textWrap = _data["textWrap"];
        }
    }

    static fromJS(data: any): ResultsOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ResultsOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openOnRun"] = this.openOnRun;
        data["textWrap"] = this.textWrap;
        return data;
    }

    clone(): ResultsOptions {
        const json = this.toJSON();
        let result = new ResultsOptions();
        result.init(json);
        return result;
    }
}

export interface IResultsOptions {
    openOnRun: boolean;
    textWrap: boolean;
}

export class Types implements ITypes {
    yesNoCancel!: YesNoCancel;
    script?: Script | undefined;
    settingsUpdated?: SettingsUpdated | undefined;
    scriptPropertyChanged?: ScriptPropertyChanged | undefined;
    scriptConfigPropertyChanged?: ScriptConfigPropertyChanged | undefined;
    scriptOutputEmitted?: ScriptOutputEmitted | undefined;
    environmentsAdded?: EnvironmentsAdded | undefined;
    environmentsRemoved?: EnvironmentsRemoved | undefined;
    environmentPropertyChanged?: EnvironmentPropertyChanged | undefined;
    activeEnvironmentChanged?: ActiveEnvironmentChanged | undefined;
    scriptDirectoryChanged?: ScriptDirectoryChanged | undefined;
    openWindowCommand?: OpenWindowCommand | undefined;
    confirmSaveCommand?: ConfirmSaveCommand | undefined;
    requestNewScriptNameCommand?: RequestNewScriptNameCommand | undefined;

    constructor(data?: ITypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yesNoCancel = _data["yesNoCancel"];
            this.script = _data["script"] ? Script.fromJS(_data["script"]) : <any>undefined;
            this.settingsUpdated = _data["settingsUpdated"] ? SettingsUpdated.fromJS(_data["settingsUpdated"]) : <any>undefined;
            this.scriptPropertyChanged = _data["scriptPropertyChanged"] ? ScriptPropertyChanged.fromJS(_data["scriptPropertyChanged"]) : <any>undefined;
            this.scriptConfigPropertyChanged = _data["scriptConfigPropertyChanged"] ? ScriptConfigPropertyChanged.fromJS(_data["scriptConfigPropertyChanged"]) : <any>undefined;
            this.scriptOutputEmitted = _data["scriptOutputEmitted"] ? ScriptOutputEmitted.fromJS(_data["scriptOutputEmitted"]) : <any>undefined;
            this.environmentsAdded = _data["environmentsAdded"] ? EnvironmentsAdded.fromJS(_data["environmentsAdded"]) : <any>undefined;
            this.environmentsRemoved = _data["environmentsRemoved"] ? EnvironmentsRemoved.fromJS(_data["environmentsRemoved"]) : <any>undefined;
            this.environmentPropertyChanged = _data["environmentPropertyChanged"] ? EnvironmentPropertyChanged.fromJS(_data["environmentPropertyChanged"]) : <any>undefined;
            this.activeEnvironmentChanged = _data["activeEnvironmentChanged"] ? ActiveEnvironmentChanged.fromJS(_data["activeEnvironmentChanged"]) : <any>undefined;
            this.scriptDirectoryChanged = _data["scriptDirectoryChanged"] ? ScriptDirectoryChanged.fromJS(_data["scriptDirectoryChanged"]) : <any>undefined;
            this.openWindowCommand = _data["openWindowCommand"] ? OpenWindowCommand.fromJS(_data["openWindowCommand"]) : <any>undefined;
            this.confirmSaveCommand = _data["confirmSaveCommand"] ? ConfirmSaveCommand.fromJS(_data["confirmSaveCommand"]) : <any>undefined;
            this.requestNewScriptNameCommand = _data["requestNewScriptNameCommand"] ? RequestNewScriptNameCommand.fromJS(_data["requestNewScriptNameCommand"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Types {
        data = typeof data === 'object' ? data : {};
        let result = new Types();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yesNoCancel"] = this.yesNoCancel;
        data["script"] = this.script ? this.script.toJSON() : <any>undefined;
        data["settingsUpdated"] = this.settingsUpdated ? this.settingsUpdated.toJSON() : <any>undefined;
        data["scriptPropertyChanged"] = this.scriptPropertyChanged ? this.scriptPropertyChanged.toJSON() : <any>undefined;
        data["scriptConfigPropertyChanged"] = this.scriptConfigPropertyChanged ? this.scriptConfigPropertyChanged.toJSON() : <any>undefined;
        data["scriptOutputEmitted"] = this.scriptOutputEmitted ? this.scriptOutputEmitted.toJSON() : <any>undefined;
        data["environmentsAdded"] = this.environmentsAdded ? this.environmentsAdded.toJSON() : <any>undefined;
        data["environmentsRemoved"] = this.environmentsRemoved ? this.environmentsRemoved.toJSON() : <any>undefined;
        data["environmentPropertyChanged"] = this.environmentPropertyChanged ? this.environmentPropertyChanged.toJSON() : <any>undefined;
        data["activeEnvironmentChanged"] = this.activeEnvironmentChanged ? this.activeEnvironmentChanged.toJSON() : <any>undefined;
        data["scriptDirectoryChanged"] = this.scriptDirectoryChanged ? this.scriptDirectoryChanged.toJSON() : <any>undefined;
        data["openWindowCommand"] = this.openWindowCommand ? this.openWindowCommand.toJSON() : <any>undefined;
        data["confirmSaveCommand"] = this.confirmSaveCommand ? this.confirmSaveCommand.toJSON() : <any>undefined;
        data["requestNewScriptNameCommand"] = this.requestNewScriptNameCommand ? this.requestNewScriptNameCommand.toJSON() : <any>undefined;
        return data;
    }

    clone(): Types {
        const json = this.toJSON();
        let result = new Types();
        result.init(json);
        return result;
    }
}

export interface ITypes {
    yesNoCancel: YesNoCancel;
    script?: Script | undefined;
    settingsUpdated?: SettingsUpdated | undefined;
    scriptPropertyChanged?: ScriptPropertyChanged | undefined;
    scriptConfigPropertyChanged?: ScriptConfigPropertyChanged | undefined;
    scriptOutputEmitted?: ScriptOutputEmitted | undefined;
    environmentsAdded?: EnvironmentsAdded | undefined;
    environmentsRemoved?: EnvironmentsRemoved | undefined;
    environmentPropertyChanged?: EnvironmentPropertyChanged | undefined;
    activeEnvironmentChanged?: ActiveEnvironmentChanged | undefined;
    scriptDirectoryChanged?: ScriptDirectoryChanged | undefined;
    openWindowCommand?: OpenWindowCommand | undefined;
    confirmSaveCommand?: ConfirmSaveCommand | undefined;
    requestNewScriptNameCommand?: RequestNewScriptNameCommand | undefined;
}

export type YesNoCancel = "Yes" | "No" | "Cancel";

export class SettingsUpdated implements ISettingsUpdated {
    settings!: Settings;

    constructor(data?: ISettingsUpdated) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.settings = new Settings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? Settings.fromJS(_data["settings"]) : new Settings();
        }
    }

    static fromJS(data: any): SettingsUpdated {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsUpdated();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }

    clone(): SettingsUpdated {
        const json = this.toJSON();
        let result = new SettingsUpdated();
        result.init(json);
        return result;
    }
}

export interface ISettingsUpdated {
    settings: Settings;
}

export abstract class PropertyChangedEvent implements IPropertyChangedEvent {
    propertyName!: string;
    newValue?: any | undefined;

    constructor(data?: IPropertyChangedEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.newValue = _data["newValue"];
        }
    }

    static fromJS(data: any): PropertyChangedEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PropertyChangedEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["newValue"] = this.newValue;
        return data;
    }

    clone(): PropertyChangedEvent {
        throw new Error("The abstract class 'PropertyChangedEvent' cannot be instantiated.");
    }
}

export interface IPropertyChangedEvent {
    propertyName: string;
    newValue?: any | undefined;
}

export class ScriptPropertyChanged extends PropertyChangedEvent implements IScriptPropertyChanged {
    scriptId!: string;

    constructor(data?: IScriptPropertyChanged) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.scriptId = _data["scriptId"];
        }
    }

    static fromJS(data: any): ScriptPropertyChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptPropertyChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        super.toJSON(data);
        return data;
    }

    clone(): ScriptPropertyChanged {
        const json = this.toJSON();
        let result = new ScriptPropertyChanged();
        result.init(json);
        return result;
    }
}

export interface IScriptPropertyChanged extends IPropertyChangedEvent {
    scriptId: string;
}

export class ScriptConfigPropertyChanged extends PropertyChangedEvent implements IScriptConfigPropertyChanged {
    scriptId!: string;

    constructor(data?: IScriptConfigPropertyChanged) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.scriptId = _data["scriptId"];
        }
    }

    static fromJS(data: any): ScriptConfigPropertyChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptConfigPropertyChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        super.toJSON(data);
        return data;
    }

    clone(): ScriptConfigPropertyChanged {
        const json = this.toJSON();
        let result = new ScriptConfigPropertyChanged();
        result.init(json);
        return result;
    }
}

export interface IScriptConfigPropertyChanged extends IPropertyChangedEvent {
    scriptId: string;
}

export class ScriptOutputEmitted implements IScriptOutputEmitted {
    scriptId!: string;
    output?: string | undefined;

    constructor(data?: IScriptOutputEmitted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): ScriptOutputEmitted {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptOutputEmitted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        data["output"] = this.output;
        return data;
    }

    clone(): ScriptOutputEmitted {
        const json = this.toJSON();
        let result = new ScriptOutputEmitted();
        result.init(json);
        return result;
    }
}

export interface IScriptOutputEmitted {
    scriptId: string;
    output?: string | undefined;
}

export class EnvironmentsAdded implements IEnvironmentsAdded {
    environments!: ScriptEnvironment[];

    constructor(data?: IEnvironmentsAdded) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.environments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["environments"])) {
                this.environments = [] as any;
                for (let item of _data["environments"])
                    this.environments!.push(ScriptEnvironment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvironmentsAdded {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentsAdded();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.environments)) {
            data["environments"] = [];
            for (let item of this.environments)
                data["environments"].push(item.toJSON());
        }
        return data;
    }

    clone(): EnvironmentsAdded {
        const json = this.toJSON();
        let result = new EnvironmentsAdded();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentsAdded {
    environments: ScriptEnvironment[];
}

export class EnvironmentsRemoved implements IEnvironmentsRemoved {
    environments!: ScriptEnvironment[];

    constructor(data?: IEnvironmentsRemoved) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.environments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["environments"])) {
                this.environments = [] as any;
                for (let item of _data["environments"])
                    this.environments!.push(ScriptEnvironment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvironmentsRemoved {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentsRemoved();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.environments)) {
            data["environments"] = [];
            for (let item of this.environments)
                data["environments"].push(item.toJSON());
        }
        return data;
    }

    clone(): EnvironmentsRemoved {
        const json = this.toJSON();
        let result = new EnvironmentsRemoved();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentsRemoved {
    environments: ScriptEnvironment[];
}

export class EnvironmentPropertyChanged extends PropertyChangedEvent implements IEnvironmentPropertyChanged {
    scriptId!: string;

    constructor(data?: IEnvironmentPropertyChanged) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.scriptId = _data["scriptId"];
        }
    }

    static fromJS(data: any): EnvironmentPropertyChanged {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentPropertyChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        super.toJSON(data);
        return data;
    }

    clone(): EnvironmentPropertyChanged {
        const json = this.toJSON();
        let result = new EnvironmentPropertyChanged();
        result.init(json);
        return result;
    }
}

export interface IEnvironmentPropertyChanged extends IPropertyChangedEvent {
    scriptId: string;
}

export class ActiveEnvironmentChanged implements IActiveEnvironmentChanged {
    scriptId?: string | undefined;

    constructor(data?: IActiveEnvironmentChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scriptId = _data["scriptId"];
        }
    }

    static fromJS(data: any): ActiveEnvironmentChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveEnvironmentChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scriptId"] = this.scriptId;
        return data;
    }

    clone(): ActiveEnvironmentChanged {
        const json = this.toJSON();
        let result = new ActiveEnvironmentChanged();
        result.init(json);
        return result;
    }
}

export interface IActiveEnvironmentChanged {
    scriptId?: string | undefined;
}

export class ScriptDirectoryChanged implements IScriptDirectoryChanged {
    scripts!: ScriptSummary[];

    constructor(data?: IScriptDirectoryChanged) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scripts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["scripts"])) {
                this.scripts = [] as any;
                for (let item of _data["scripts"])
                    this.scripts!.push(ScriptSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScriptDirectoryChanged {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptDirectoryChanged();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.scripts)) {
            data["scripts"] = [];
            for (let item of this.scripts)
                data["scripts"].push(item.toJSON());
        }
        return data;
    }

    clone(): ScriptDirectoryChanged {
        const json = this.toJSON();
        let result = new ScriptDirectoryChanged();
        result.init(json);
        return result;
    }
}

export interface IScriptDirectoryChanged {
    scripts: ScriptSummary[];
}

export abstract class Command implements ICommand {
    id!: string;

    constructor(data?: ICommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Command {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Command' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Command {
        throw new Error("The abstract class 'Command' cannot be instantiated.");
    }
}

export interface ICommand {
    id: string;
}

export class OpenWindowCommand extends Command implements IOpenWindowCommand {
    windowName!: string;
    options!: WindowOptions;
    metadata!: { [key: string]: any; };

    constructor(data?: IOpenWindowCommand) {
        super(data);
        if (!data) {
            this.options = new WindowOptions();
            this.metadata = {};
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.windowName = _data["windowName"];
            this.options = _data["options"] ? WindowOptions.fromJS(_data["options"]) : new WindowOptions();
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): OpenWindowCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OpenWindowCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["windowName"] = this.windowName;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = this.metadata[key];
            }
        }
        super.toJSON(data);
        return data;
    }

    clone(): OpenWindowCommand {
        const json = this.toJSON();
        let result = new OpenWindowCommand();
        result.init(json);
        return result;
    }
}

export interface IOpenWindowCommand extends ICommand {
    windowName: string;
    options: WindowOptions;
    metadata: { [key: string]: any; };
}

export class WindowOptions implements IWindowOptions {
    height!: number;
    width!: number;

    constructor(data?: IWindowOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.height = _data["height"];
            this.width = _data["width"];
        }
    }

    static fromJS(data: any): WindowOptions {
        data = typeof data === 'object' ? data : {};
        let result = new WindowOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["height"] = this.height;
        data["width"] = this.width;
        return data;
    }

    clone(): WindowOptions {
        const json = this.toJSON();
        let result = new WindowOptions();
        result.init(json);
        return result;
    }
}

export interface IWindowOptions {
    height: number;
    width: number;
}

export abstract class CommandOfYesNoCancel extends Command implements ICommandOfYesNoCancel {

    constructor(data?: ICommandOfYesNoCancel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CommandOfYesNoCancel {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandOfYesNoCancel' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): CommandOfYesNoCancel {
        throw new Error("The abstract class 'CommandOfYesNoCancel' cannot be instantiated.");
    }
}

export interface ICommandOfYesNoCancel extends ICommand {
}

export class ConfirmSaveCommand extends CommandOfYesNoCancel implements IConfirmSaveCommand {
    message!: string;

    constructor(data?: IConfirmSaveCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ConfirmSaveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmSaveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        super.toJSON(data);
        return data;
    }

    clone(): ConfirmSaveCommand {
        const json = this.toJSON();
        let result = new ConfirmSaveCommand();
        result.init(json);
        return result;
    }
}

export interface IConfirmSaveCommand extends ICommandOfYesNoCancel {
    message: string;
}

export abstract class CommandOfString extends Command implements ICommandOfString {

    constructor(data?: ICommandOfString) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CommandOfString {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandOfString' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): CommandOfString {
        throw new Error("The abstract class 'CommandOfString' cannot be instantiated.");
    }
}

export interface ICommandOfString extends ICommand {
}

export class RequestNewScriptNameCommand extends CommandOfString implements IRequestNewScriptNameCommand {
    currentScriptName!: string;

    constructor(data?: IRequestNewScriptNameCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currentScriptName = _data["currentScriptName"];
        }
    }

    static fromJS(data: any): RequestNewScriptNameCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RequestNewScriptNameCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentScriptName"] = this.currentScriptName;
        super.toJSON(data);
        return data;
    }

    clone(): RequestNewScriptNameCommand {
        const json = this.toJSON();
        let result = new RequestNewScriptNameCommand();
        result.init(json);
        return result;
    }
}

export interface IRequestNewScriptNameCommand extends ICommandOfString {
    currentScriptName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}